{
  "title": "Priority Queues, Heaps, and Binary Heaps.",
  "publishedAt": "2021-10-18",
  "summary": "What is a priority queue? How is it internally implemented? How should I use one?",
  "body": {
    "raw": "\n# Introduction\n\nAs you can see in the name, it's a queue, but it isn't a\n[FIFO](<https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)>) data structure. Moreover, it has priorities.\nWhich priorities? Well....\n\nHave you guessed it? You might think, \"Doesn't it use some kind of size comparison?\"\nYes. It uses size comparisons, but it's more extended. What? Extended? No, never mind.\nFor now, I'll just discuss what a priority queue is.\n\n# Definition\n\nTo begin with, a priority queue is a data structure that performs several operations such as peeking (or to say, getting) the top element\n(I'll explain what's the top element later), popping the top element, and pushing a new element into the priority queue.\n\nAll of these operations work at a time complexity of `O(log n)`.\n(The reference is [this](https://en.cppreference.com/w/cpp/container/priority_queue).)\nQuite fast, huh? Oh, and you might guess, \"Does it use a tree?\"\n\nYes. It uses a tree, but not any tree. It uses a binary heap to manage its elements.\n\n# Binary heap\n\n[What's a binary heap?](https://en.wikipedia.org/wiki/Binary_heap)\nFirst, a heap always has the extremest (e.g. smallest, largest) element at the root.\nIt keeps the order by swapping parent-child nodes when a change occurs.\nAnd a binary heap is a heap where every element (except for leaf nodes) has exactly two children.\nHow does it manage the order? Well, for this one, I'll just quote Wikipedia.\n(The image might look dark, so consider turning off dark mode if you are using it. Just my two cents.)\n\n> To add an element to a heap, we can perform this algorithm:\n> Add the element to the bottom level of the heap at the leftmost open space.\n> Compare the added element with its parent; if they are in the correct order, stop.\n> If not, swap the element with its parent and return to the previous step.\n> Steps 2 and 3, which restore the heap property by comparing and possibly swapping a node with its parent, are called the up-heap operation (also known as bubble-up, percolate-up, sift-up, trickle-up, swim-up, heapify-up, or cascade-up).\n> The number of operations required depends only on the number of levels the new element must rise to satisfy the heap property. Thus, the insertion operation has a worst-case time complexity of O(log n). For a random heap, and for repeated insertions, the insertion operation has an average-case complexity of O(1).\n> As an example of binary heap insertion, say we have a max-heap\n> ![](https://upload.wikimedia.org/wikipedia/commons/a/ac/Heap_add_step1.svg)\n> and we want to add the number 15 to the heap. We first place the 15 in the position marked by the X. However, the heap property is violated since 15 > 8, so we need to swap the 15 and the 8. So, we have the heap looking as follows after the first swap:\n> ![](https://upload.wikimedia.org/wikipedia/commons/1/16/Heap_add_step2.svg)\n> However the heap property is still violated since 15 > 11, so we need to swap again:\n> ![](https://upload.wikimedia.org/wikipedia/commons/5/51/Heap_add_step3.svg)\n> which is a valid max-heap. There is no need to check the left child after this final step: at the start, the max-heap was valid, meaning the root was already greater than its left child, so replacing the root with an even greater value will maintain the property that each node is greater than its children (11 > 5; if 15 > 11, and 11 > 5, then 15 > 5, because of the transitive relation).\n\nLong story short, it puts the new element at the bottom of the heap,\nand it keeps swapping it with its parent until it complies with the comparison function.\n\n---\n\nOkay... so now we know that a priority queue uses a binary heap and what a binary heap is, but anyway, what are these operations?\nAs I said, there are three operations. However, before we discuss these operations, let's first initialize a priority queue.\nHere comes the code, so don't panic. (For sake of brevity, I'll just use `int` as the element type.)\n\n# Operations of Priority Queues\n\n## Initialization\n\n### Largest element on top\n\n```cpp\n#include <priority_queue>\n\npriority_queue<int> pq;\n```\n\nEasy as cake, huh?\n\nNow, let's dive deeper into what this really means.\nFirst, `priority_queue` is a STL data structure. It accepts a template parameter, and we can put the type `int` there.\n\n### Smallest element on top\n\nHowever, this declaration yields a priority queue which gives the biggest element on top.\nIf you want the priority queue to give the smallest element on top,\nyou can write like this.\n\n```cpp\n#include <priority_queue>\n\npriority_queue<int, vector<int>, greater<int>> pq;\n```\n\nWhat I just did is, I manually added a container to the priority queue, which is usually redundant,\nbut because we need to set the third parameter to `greater<int>`, I added it.\nAnd most importantly, `greater<int>` reverses the comparison function, which makes the smallest element go on top.\n\n**However, for custom template types, `greater<T>` should be defined.**\n\n# Pushing elements\n\nNow that we discussed about how to declare the priority queue, let's talk about how to actually push an element to the priority queue.\n\nIt's actually simpler than declaring a priority queue. Just type this: `pq.push(SOME_NUMBER);` Here, `SOME_NUMBER` is any number. _Fin._\n\n# Peeking elements\n\nWe pushed an element, so what should we do next? Well, we should now peek what's on the top.\nThat's also simple, with just one line of code: `pq.top();`\nIt gives us the top element, to say, the _extreme_ element.\n\n# Popping elements\n\nPushed, peeked. Now we should pop it, to make it empty. How to do it? `pq.pop();` Easy.\n\n# Example\n\nNow, a full example of how to use a priority queue.\n\n```cpp:priority_queue.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\npriority_queue<int> pq;\n\nint main() {\n    pq.push(3);                 // pq: [3]\n    pq.push(7);                 // pq: [7, 3]\n    pq.push(4);                 // pq: [7, 4, 3]\n    pq.push(5);                 // pq: [7, 5, 4, 3]\n    pq.push(-3);                // pq: [7, 5, 4, 3, -3]\n    cout << pq.top() << \"\\n\";   // Output: \"7\"\n    pq.pop();                   // pq: [5, 4, 3, -3]\n    cout << pq.top() << \"\\n\";   // Output: \"5\"\n    return 0;\n}\n```\n\n# Summary\n\nTo summarize, priority queues are used to get the _extreme element,_\nthey are internally implemented using binary heaps,\nand their main three functions are `pq.push(SOME_VALUE)`, `pq.top()`, and `pq.pop()`.\n\nI hope this summarizes well, and if you have anything to say, please leave the comments below.\nIt could be anything – appreciation, information, wisdom, or even humor.\n\nAnyway, have a great day.\n\nSee you next time, bye. 🍻\n",
    "html": "<h1>Introduction</h1>\n<p>As you can see in the name, it's a queue, but it isn't a\n<a href=\"https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)\">FIFO</a> data structure. Moreover, it has priorities.\nWhich priorities? Well....</p>\n<p>Have you guessed it? You might think, \"Doesn't it use some kind of size comparison?\"\nYes. It uses size comparisons, but it's more extended. What? Extended? No, never mind.\nFor now, I'll just discuss what a priority queue is.</p>\n<h1>Definition</h1>\n<p>To begin with, a priority queue is a data structure that performs several operations such as peeking (or to say, getting) the top element\n(I'll explain what's the top element later), popping the top element, and pushing a new element into the priority queue.</p>\n<p>All of these operations work at a time complexity of <code>O(log n)</code>.\n(The reference is <a href=\"https://en.cppreference.com/w/cpp/container/priority_queue\">this</a>.)\nQuite fast, huh? Oh, and you might guess, \"Does it use a tree?\"</p>\n<p>Yes. It uses a tree, but not any tree. It uses a binary heap to manage its elements.</p>\n<h1>Binary heap</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Binary_heap\">What's a binary heap?</a>\nFirst, a heap always has the extremest (e.g. smallest, largest) element at the root.\nIt keeps the order by swapping parent-child nodes when a change occurs.\nAnd a binary heap is a heap where every element (except for leaf nodes) has exactly two children.\nHow does it manage the order? Well, for this one, I'll just quote Wikipedia.\n(The image might look dark, so consider turning off dark mode if you are using it. Just my two cents.)</p>\n<blockquote>\n<p>To add an element to a heap, we can perform this algorithm:\nAdd the element to the bottom level of the heap at the leftmost open space.\nCompare the added element with its parent; if they are in the correct order, stop.\nIf not, swap the element with its parent and return to the previous step.\nSteps 2 and 3, which restore the heap property by comparing and possibly swapping a node with its parent, are called the up-heap operation (also known as bubble-up, percolate-up, sift-up, trickle-up, swim-up, heapify-up, or cascade-up).\nThe number of operations required depends only on the number of levels the new element must rise to satisfy the heap property. Thus, the insertion operation has a worst-case time complexity of O(log n). For a random heap, and for repeated insertions, the insertion operation has an average-case complexity of O(1).\nAs an example of binary heap insertion, say we have a max-heap\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/ac/Heap_add_step1.svg\" alt=\"\">\nand we want to add the number 15 to the heap. We first place the 15 in the position marked by the X. However, the heap property is violated since 15 > 8, so we need to swap the 15 and the 8. So, we have the heap looking as follows after the first swap:\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/1/16/Heap_add_step2.svg\" alt=\"\">\nHowever the heap property is still violated since 15 > 11, so we need to swap again:\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/5/51/Heap_add_step3.svg\" alt=\"\">\nwhich is a valid max-heap. There is no need to check the left child after this final step: at the start, the max-heap was valid, meaning the root was already greater than its left child, so replacing the root with an even greater value will maintain the property that each node is greater than its children (11 > 5; if 15 > 11, and 11 > 5, then 15 > 5, because of the transitive relation).</p>\n</blockquote>\n<p>Long story short, it puts the new element at the bottom of the heap,\nand it keeps swapping it with its parent until it complies with the comparison function.</p>\n<hr>\n<p>Okay... so now we know that a priority queue uses a binary heap and what a binary heap is, but anyway, what are these operations?\nAs I said, there are three operations. However, before we discuss these operations, let's first initialize a priority queue.\nHere comes the code, so don't panic. (For sake of brevity, I'll just use <code>int</code> as the element type.)</p>\n<h1>Operations of Priority Queues</h1>\n<h2>Initialization</h2>\n<h3>Largest element on top</h3>\n<pre><code class=\"language-cpp\">#include &#x3C;priority_queue>\n\npriority_queue&#x3C;int> pq;\n</code></pre>\n<p>Easy as cake, huh?</p>\n<p>Now, let's dive deeper into what this really means.\nFirst, <code>priority_queue</code> is a STL data structure. It accepts a template parameter, and we can put the type <code>int</code> there.</p>\n<h3>Smallest element on top</h3>\n<p>However, this declaration yields a priority queue which gives the biggest element on top.\nIf you want the priority queue to give the smallest element on top,\nyou can write like this.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;priority_queue>\n\npriority_queue&#x3C;int, vector&#x3C;int>, greater&#x3C;int>> pq;\n</code></pre>\n<p>What I just did is, I manually added a container to the priority queue, which is usually redundant,\nbut because we need to set the third parameter to <code>greater&#x3C;int></code>, I added it.\nAnd most importantly, <code>greater&#x3C;int></code> reverses the comparison function, which makes the smallest element go on top.</p>\n<p><strong>However, for custom template types, <code>greater&#x3C;T></code> should be defined.</strong></p>\n<h1>Pushing elements</h1>\n<p>Now that we discussed about how to declare the priority queue, let's talk about how to actually push an element to the priority queue.</p>\n<p>It's actually simpler than declaring a priority queue. Just type this: <code>pq.push(SOME_NUMBER);</code> Here, <code>SOME_NUMBER</code> is any number. <em>Fin.</em></p>\n<h1>Peeking elements</h1>\n<p>We pushed an element, so what should we do next? Well, we should now peek what's on the top.\nThat's also simple, with just one line of code: <code>pq.top();</code>\nIt gives us the top element, to say, the <em>extreme</em> element.</p>\n<h1>Popping elements</h1>\n<p>Pushed, peeked. Now we should pop it, to make it empty. How to do it? <code>pq.pop();</code> Easy.</p>\n<h1>Example</h1>\n<p>Now, a full example of how to use a priority queue.</p>\n<pre><code class=\"language-cpp:priority_queue.cpp\">#include &#x3C;bits/stdc++.h>\n\nusing namespace std;\n\npriority_queue&#x3C;int> pq;\n\nint main() {\n    pq.push(3);                 // pq: [3]\n    pq.push(7);                 // pq: [7, 3]\n    pq.push(4);                 // pq: [7, 4, 3]\n    pq.push(5);                 // pq: [7, 5, 4, 3]\n    pq.push(-3);                // pq: [7, 5, 4, 3, -3]\n    cout &#x3C;&#x3C; pq.top() &#x3C;&#x3C; \"\\n\";   // Output: \"7\"\n    pq.pop();                   // pq: [5, 4, 3, -3]\n    cout &#x3C;&#x3C; pq.top() &#x3C;&#x3C; \"\\n\";   // Output: \"5\"\n    return 0;\n}\n</code></pre>\n<h1>Summary</h1>\n<p>To summarize, priority queues are used to get the <em>extreme element,</em>\nthey are internally implemented using binary heaps,\nand their main three functions are <code>pq.push(SOME_VALUE)</code>, <code>pq.top()</code>, and <code>pq.pop()</code>.</p>\n<p>I hope this summarizes well, and if you have anything to say, please leave the comments below.\nIt could be anything – appreciation, information, wisdom, or even humor.</p>\n<p>Anyway, have a great day.</p>\n<p>See you next time, bye. 🍻</p>"
  },
  "_id": "posts/priority-queue.mdx",
  "_raw": {
    "sourceFilePath": "posts/priority-queue.mdx",
    "sourceFileName": "priority-queue.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/priority-queue"
  },
  "type": "Blog",
  "readingTime": {
    "text": "4 min read",
    "minutes": 3.8727272727272726,
    "time": 232364,
    "words": 1065
  },
  "wordCount": 1067,
  "tweetIds": [],
  "slug": "priority-queue"
}